((#F[A-F]F[A-F]F[A-F])|(白色)).*(原神|(O|o)(P|p))[^启]*((启[^启]*启[^启]*启)+[^启]*动+)
一开始写出答案还挺轻松的，后面启动元素直接写成.*(启+.*动+)就能过，直到我开始着手附加题部分。按照正常的逻辑，我开始想办法统计字符串中“启”字的个数并尝试整除3，然后发现正则表达式在逻辑判断这一方面完全没有力量，所以开始不断地搜索关于统计字符总数的方法，刷了半个小时浏览器啥都没找到。最多的反而是判断数字能被三整除，这个是一个有够奇怪，不如x%3==0的垃圾问题。然后想到了（启启启）+的方法，但是不能匹配不连续字符，于是又开始找不连续字符的计数，也没找到，最终选择了[^启]*的方法来统计中间可能存在的字符，并且将旁边的几个.*都改成了[^启]*才好像搞出了这个冗长的答案。
但是还是有个缺陷，对于字符串“启动启启”处理不了，而这个字符串是满足题干中“按顺序出现‘启’‘动’”这个条件的。实在想不出解决方案了就这样吧。